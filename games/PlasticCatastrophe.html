<!DOCTYPE html>
<html>
<head>
<title> Plastic Catastrophe </title>
<link rel="icon" type="image/png" href="../images/favicon.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
</head>
<body>
	<ul class="topnav">
		<li><a href="../index.html">Home</a></li>
		<li><a href="../index.html#About">About</a></li>
		<li><a href="../index.html#Projects">Projects</a></li>
		<li><a href="../index.html#Contact">Contact</a></li>
	</ul>

<div  class="emptydiv" id="Top"></div>

<div class=contentlarge>
	<h1>Plastic Catastrophe</h1>
	<h4>An augmented reality game where the player trains animals and cleans up the environment</h4>
	<br>
	<img src="../images/Plastic_Catastrophe_Splashscreen_V.1.jpg" width="75%" align="middle">
	<br>
	<h3>Current Features</h3>
	<ul>
		<li><p>Inventory and shop system.</p></li>
		<li><p>Virtual map that tracks the player's location using GPS.</p></li>
		<li><p>Character selection and leveling</p></li>
	</ul>
</div>

<div class="contentlarge" style="background-color: #16213E">
	<h3>About the project</h3>
	<p>This project was made during my study at the Hanzehogeschool, the goal of the project was to raise the awareness of plastic pollution.<br>
	Since plastic waste decomposes very slowly and tons of it eventually ends up in bodies of water, our main focus was on nature in and around water.</p>
	<p>The game itself was made in a team of 7: 3 artists, 2 designers and another programmer. In this project I worked on the GPS map, minigames, character selection & leveling, Item spawning and the pollution system among other things.<br></p>
	<br>
	<img src="../images/PCMap.PNG" width="20%" align="middle">
	<br><br>
	<p>
		The game is made for mobile devices and uses the device's GPS to place the player in the right position of the virtual map. <br>
		The map itself was made using the Mapbox SDK for Unity, this package allowed us to customize how the map looked in game and leave out redundant information like location names.<br>
	</p>
	<p>
		The goal of the game is to clean up the environment with a selection of animals, waste items will spawn on the map around the player as they walk around which the player can interact with.<br>
		A minigame will start when the player interacts with an item, this minigame needs to be won to succesfully pick up that item.<br>
		The minigame the player needs to play depends on the lead animal which the player selected. There currently are 3 animals in the game: Seagul, Seal and Turtle, each animal has its own minigame as well: the seagul's minigame focuses on getting the right timing to drop the item in the basket, the seal needs to be held upright as it balances the item towards the basket and the turtle needs to aim his slingshot to hit the target.<br>
		After completing the minigame, the player receives the item and the lead animal receives experience based on the dangers that item poses to its species. 
	</p>
	
	<h3 id="Block1">Character system</h3>
	<p>The 3 characters the player can pick</p>
	<div class=CodeWindow>
		<a href="../samples/PCCharSystem.html" class="previewLink">
			<div><p>Character script(Click for full view)</p></div>
		</a>
		<pre class="Preview">
		using System.Collections.Generic;
		using UnityEngine;
	
		public class GenerateWorld : MonoBehaviour
		{
			[SerializeField]
			bool AutoSeed; //if true, will generate a random seed on Start
	
			[SerializeField]
			int MapSize;
	
			[SerializeField]
			int LevelSeed; 
	
			[SerializeField]
			List<GameObject> LargeStructures = new List<GameObject>();
	
			[SerializeField]
			List<GameObject> MediumStructures = new List<GameObject>();
	
			[SerializeField]
			List<GameObject> SmallStructures = new List<GameObject>();
	
			[SerializeField]
			float[] StartWeights; //random weights at the center of the play area
	
			[SerializeField]
			float[] EndWeights; //random weights at the end of the play area
	
			[SerializeField]
			int overlapTestBoxSize;
	
			public System.Random Seed;
	
	
			// Start is called before the first frame update, generates seed if none is given
			void Start()
			{
				GameManager.instance.WorldGenerator = this;
				if (AutoSeed)
				{
					LevelSeed = Random.Range(0, int.MaxValue);
					Seed = new System.Random(LevelSeed);
				}
				else
				{
					Seed = new System.Random(LevelSeed);
				}
	
				SpawnStructures(60);
			}
	
			//picks the type(small, medium or large) the structure is going to be, based on distance from the player's spawn point(0, 0)
			List<GameObject> PickStructureType(Vector3 Location)
			{
				float CurrentWeight = 0;
				float[] Localweights = new float[StartWeights.Length]; 
	
				float RandomNbr = (float)Seed.NextDouble();
	
				for (int i = 0; i < StartWeights.Length; i++)
				{
					float LocalWeight = Mathf.Lerp(StartWeights[i], EndWeights[i], Vector3.Distance(Vector3.zero, Location) / Vector3.Distance(Vector3.zero, new Vector3(MapSize, 0, MapSize)));
					Localweights[i] = LocalWeight;
	
					if (CurrentWeight + LocalWeight >= (RandomNbr))
					{
						switch (i)
						{
							case 0:
								return SmallStructures;
	
							case 1:
								return MediumStructures;
	
							case 2:
								return LargeStructures;
						}
					}else
					{
						CurrentWeight += LocalWeight;
					}
				}
	
				Debug.LogError("Couldn't generate type");
	
				return null;
			}
	
			void SpawnStructures(int amount)
			{
				for (int i = 0; i < amount; i++)
				{
	
					Vector3 Pos = new Vector3(Seed.Next(-MapSize, MapSize), 0, Seed.Next(-MapSize, MapSize));
					Quaternion Rot = Quaternion.Euler(0, Seed.Next(0, 361), 0);
	
					List<GameObject> PickedList = new List<GameObject>();
	
					PickedList = PickStructureType(Pos);
	
					//detects overlap
					Vector3 overlapTestBoxScale = new Vector3(overlapTestBoxSize, overlapTestBoxSize, overlapTestBoxSize);
					Collider[] collidersInsideOverlapBox = new Collider[1];
					int numberOfCollidersFound = Physics.OverlapBoxNonAlloc(Pos, overlapTestBoxScale, collidersInsideOverlapBox, Rot);
	
					if (numberOfCollidersFound == 0)
					{
						GameObject Structure = Instantiate(PickedList[Seed.Next(0, PickedList.Count)]);
						Structure.transform.position = Pos;
						Structure.transform.rotation = Rot;
					}
					else
					{
						Debug.Log("collider found, skipping structure.");
					}
	
				}
			}
	
		}
		
		</pre>
	</div>

</div>
</div>

</body>
</html>
