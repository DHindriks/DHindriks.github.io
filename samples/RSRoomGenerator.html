<!DOCTYPE html>
<html>
<head>
<title> Room generator script - Sector Unknown </title>
<link rel="icon" type="image/png" href="../images/favicon.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" type="text/css" href="../css/style.css" />
</head>
<body>

<ul class="topnav">
	<li><a href="../games/SectorUnknown.html#Block2">Close</a></li>
</ul>

<pre class="CodeLightBox">
	using System.Collections;
	using System.Collections.Generic;
	using UnityEngine;
	
	public class RoomSpawnPoint : MonoBehaviour
	{
		DungeonGenerator Generator;
	
		List&lt;Transform&gt; SpawnPoints = new List&lt;Transform&gt;();
		[Space(40)]
		public List&lt;GameObject&gt; Interiors; //possible interiors the rooms can contain
	
		void Awake()
		{
			Generator = GetComponentInParent&lt;DungeonGenerator&gt;();
			foreach (MeshRenderer renderer in GetComponentsInChildren&lt;MeshRenderer&gt;())
			{
				if (renderer.gameObject.tag == "Floor")
				{
					renderer.material = Generator.Data.FloorMat;
				}else
				{
					renderer.material = Generator.Data.WallMat;
				}
			}
			Invoke("SpawnTile", Random.Range(0.1f, 0.4f));
		}
	
		void SpawnTile()
		{
			for (int i = 0; i &lt; transform.GetChild(0).transform.childCount; i++)
			{
				SpawnPoints.Add(transform.GetChild(0).GetChild(i));
	
				Transform CurrentSpawnPoint = transform.GetChild(0).GetChild(i);
	
	
				//detects overlap
				Vector3 overlapTestBoxScale = new Vector3(20, 10, 20);
				Collider[] collidersInsideOverlapBox = new Collider[1];
				int numberOfCollidersFound = Physics.OverlapBoxNonAlloc(CurrentSpawnPoint.position, overlapTestBoxScale, collidersInsideOverlapBox);
	
	
				if (numberOfCollidersFound != 0 && collidersInsideOverlapBox[0].transform.root != transform.root) //if overlap, spawn hardwall.
				{
					GameObject NewTile = Instantiate(Generator.HardWall, transform.parent);
	
					NewTile.transform.position = transform.GetChild(0).GetChild(i).position;
					NewTile.transform.LookAt(transform, Vector3.up);
				}else if (Generator.CurrentLength &lt;= Generator.PickedLength && numberOfCollidersFound == 0) //if more tiles need to be spawned, no overlap.
				{
					//calculate if next room will be a dead end, based on amount of connecting points(max 75% chance min 0% chance)
					float Randomnmbr = Random.Range(0f, 1f);
					float Chance = 1f / (transform.GetChild(0).childCount - i);
					//spawn random dead end.
					if (Randomnmbr &gt; Chance)
					{
						GameObject NewTile = Instantiate(Generator.Deadend, transform.parent);
						NewTile.transform.position = transform.GetChild(0).GetChild(i).position;
						NewTile.transform.LookAt(transform, Vector3.up);
						Generator.CurrentLength++;
						Generator.CurrentDungeonDeadEnds.Add(NewTile);
					}
					else //spawn normal 
					{
						GameObject NewTile = Instantiate(Generator.Tiles[Random.Range(0, Generator.Tiles.Count)], transform.parent);
						NewTile.transform.position = transform.GetChild(0).GetChild(i).position;
						NewTile.transform.LookAt(transform, Vector3.up);
						Generator.CurrentLength++;
						Generator.CurrentDungeonTiles.Add(NewTile);
					}
	
				}
				else if (numberOfCollidersFound == 0) //no overlap and no more tiles to be spawned.
				{
					GameObject NewTile = Instantiate(Generator.Deadend, transform.parent);
	
					NewTile.transform.position = transform.GetChild(0).GetChild(i).position;
					NewTile.transform.LookAt(transform, Vector3.up);
					Generator.CurrentLength++;
					Generator.CurrentDungeonDeadEnds.Add(NewTile);
				}
	
			}
			Generator.CheckRoomCount();
		}
	
		public void SpawnInterior(GameObject custom = null)
		{
			if (Interiors.Count &gt; 0 || custom != null)
			{
				if (custom == null)
				{
					custom = Interiors[Random.Range(0, Interiors.Count)];
				}
	
				GameObject Interior = Instantiate(custom, transform);
				Interior.transform.position = transform.position;
				Interior.transform.rotation = transform.rotation;
			}
		}
	
	}
            </pre>

</body>
</html>
